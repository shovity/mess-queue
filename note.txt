Nó là message queue
Module mình gọi trên app service thôi em
Kafka thì là 1 app độc lập. Mình ko build theo hướng đó
sẽ mất nhiều time, và yeu cầu sẽ phải cao hơn. Ko cần thiết.
Kafka cũng ko cần redis, còn mình thì build hướng sử dụng redis làm store.

-hôm trước a cho xem cái mô hình kafka trên web lên em tưởng anh muốn build trên kiến trúc đó.
-vậy là vẫn có 1 queue trên redis, topic.
-Còn parttion như hôm trước anh vẽ để làm gì ạ, tại nó là nơi lưu message trong kafka.

Dựa theo kiến trúc tổ chức của kafka. Theo ý tưởng logic của nó thôi.
Partition, hiểu là cơ chế cho phép async cái meassage của queue
Kafka sử dụng hệ thống Log File trên ổ đĩa để store message
Của mình thay dùng file sử dụng redis cho nhanh.

-mình xử lý từng message 1, xong cái này mới đến cái kia, hay nạp hết vào các topic ạ

Message đc store ở lớp Partition (hay cách goi khác là Stream)
1 Topic có 1 hoặc nhiều Stream
Khi bắn message thì bắn không tuần tự vào Stream
Nhưng xử lý message trong từng Stream là tuần tự.

-vâng ạ, em tưởng store vào 1 cái queue rồi chuyển lần lượt vào topic tương ứng để xử lý :D

Stream là queue đấy
Bắn bao nhiêu nó hold ở đó hết
Còn cronjob lấy từng message ở Stream ra xử lý thì bất đồng bộ.

-nhưng mà như thế thì lại giống cái rabbit mà hôm trước a cho e xem

Khác đấy
Vì o đây em mới lưu tâm đến mức Partition

-mà xử lý xong là xóa ngay hay giữ lại như kafka

Kafka lưu file như log. Ko cần xoá
Vì chi phí xoá còn lớn hơn giữ

Nhưng dùng redis thì phải tính phương án loại

-mỗi parttion có 1 handle riêng hay mình đăng ký handle cho 1 hoặc nhiều partition ạ?

Đấy cũng là một cái khác
Mình bắt handle cho từng loại Message

Ví dụ: em có topic là Log
Message type để handle, có thể có những loại: LogCreatedEvent, LogRemoveEvent, LogUpdateEvent, ....
Ví dụ Log lại lưu vào redis và es
Thì lại cần handle chi tiết cho redis và elastic nữa
